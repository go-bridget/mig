package golang

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"path"
	"strings"

	"github.com/apex/log"
	"github.com/pkg/errors"

	"github.com/go-bridget/mig/cmd/mig/gen/model"
	"github.com/go-bridget/mig/cmd/mig/internal"
)

var numericTypes map[string]string = map[string]string{
	"tinyint":  "int8",
	"smallint": "int16",
	// `mediumint` - this one would, technically, be int24 (3 bytes), but
	"mediumint": "int32",
	"int":       "int32",
	"bigint":    "int64",
}

func isNumeric(column *internal.Column) (string, bool) {
	typeName := column.DataType

	// sized datatype, remove size hint
	if idx := strings.Index(typeName, "("); idx != -1 {
		typeName = typeName[:idx]
	}

	val, ok := numericTypes[typeName]
	return val, ok
}

var simpleTypes map[string]string = map[string]string{
	"char":       "string",
	"varchar":    "string",
	"text":       "string",
	"longtext":   "string",
	"mediumtext": "string",
	"tinytext":   "string",
	"longblob":   "[]byte",
	"blob":       "[]byte",
	"binary":     "[]byte",
	"varbinary":  "[]byte",
	"boolean":    "bool",
	// `float` and `double` are here since they don't have unsigned modifiers
	"float":  "float32",
	"double": "float64",
	// `decimal` - double stored as string, \o/
	"decimal": "string",
	// some coalescing for year/enum types
	"year": "int",
	"enum": "string",
}

func isSimple(column *internal.Column) (string, bool) {
	typeName := column.DataType

	// sized datatype, remove size hint
	if idx := strings.Index(typeName, "("); idx != -1 {
		typeName = typeName[:idx]
	}

	val, ok := simpleTypes[typeName]
	return val, ok
}

type specialType struct {
	Import string
	Type   string
}

var specialTypes map[string]specialType = map[string]specialType{
	"date":      specialType{"time", "*time.Time"},
	"datetime":  specialType{"time", "*time.Time"},
	"time":      specialType{"time", "*time.Time"},
	"timestamp": specialType{"time", "*time.Time"},
	// `set` is not implemented
	"json": specialType{"sqlxTypes github.com/jmoiron/sqlx/types", "sqlxTypes.JSONText"},
}

func isSpecial(column *internal.Column) (specialType, bool) {
	val, ok := specialTypes[column.DataType]
	return val, ok
}

func resolveTypeGo(column *internal.Column) (string, error) {
	if val, ok := isSimple(column); ok {
		return val, nil
	}
	if val, ok := isNumeric(column); ok {
		isUnsigned := strings.Contains(strings.ToLower(column.Type), "unsigned")
		if isUnsigned {
			return "u" + val, nil
		}
		return val, nil
	}
	if val, ok := isSpecial(column); ok {
		return val.Type, nil
	}
	return "", errors.Errorf("Unsupported SQL type: %s", column.DataType)
}

func Render(options model.Options, tables []*internal.Table) error {
	var (
		output = options.Output
	)

	imports := []string{
		"\"fmt\"",
		"\"strings\"",
	}

	// Loop through tables/columns, return type error if any
	// This also builds the `imports` slice for codegen lower
	for _, table := range tables {
		// add trailing dot (godoc)
		if table.Comment != "" && !strings.HasSuffix(table.Comment, ".") {
			table.Comment += "."
		}

		for _, column := range table.Columns {
			if val, ok := isSpecial(column); ok {
				importString := fmt.Sprintf("\"%s\"", val.Import)
				// "x y" => import x "y"
				if strings.Contains(val.Import, " ") {
					parts := strings.Split(val.Import, " ")
					importString = fmt.Sprintf("%s \"%s\"", parts[0], parts[1])
				}
				if !internal.Contains(imports, importString) {
					imports = append(imports, importString)
				}
			}
		}
	}

	buf := bytes.NewBuffer([]byte{})

	fmt.Fprintf(buf, "package %s\n", path.Base(output))
	fmt.Fprintln(buf)
	fmt.Fprintln(buf, "// Code generated by go-bridget/mig. DO NOT EDIT.")
	fmt.Fprintln(buf)

	// Print collected imports
	if len(imports) > 0 {
		fmt.Fprintln(buf, "import (")
		nl := false
		for _, val := range imports {
			if !strings.Contains(val, " ") {
				fmt.Fprintf(buf, "\t%s\n", val)
			} else {
				nl = true
			}
		}
		if nl {
			fmt.Fprintln(buf)
		}
		for _, val := range imports {
			if strings.Contains(val, " ") {
				fmt.Fprintf(buf, "\t%s\n", val)
			}
		}
		fmt.Fprintln(buf, ")")
		fmt.Fprintln(buf)
	}

	renderQueryBuilders(buf)

	for _, table := range tables {
		fields := []string{}
		primary := []string{}
		helpers := []string{}

		if table.Ignore() {
			continue
		}

		tableName := internal.Camel(table.Name)

		// Take care of the helpers (getters, limited setters).
		for _, column := range table.Columns {
			columnName := internal.Camel(column.Name)
			columnType, err := resolveTypeGo(column)
			if err != nil {
				return err
			}

			receiver := strings.ToLower(string(tableName[0]))
			helpers = append(helpers, []string{
				fmt.Sprintf("// Get%s will return the value of %s.", columnName, columnName),
				fmt.Sprintf("func (%s *%s) Get%s() %s { return %s.%s }", receiver, tableName, columnName, columnType, receiver, columnName),
			}...)

			if columnType == "*time.Time" {
				receiver := strings.ToLower(string(tableName[0]))
				helpers = append(helpers, []string{
					fmt.Sprintf("// Set%s sets %s to the provided value.", columnName, columnName),
					fmt.Sprintf("func (%s *%s) Set%s(stamp time.Time) { %s.%s = &stamp }", receiver, tableName, columnName, receiver, columnName),
				}...)
			}
		}

		fmt.Fprintf(buf, "// %s generated for db table `%s`.\n", tableName, table.Name)
		if table.Comment != "" {
			fmt.Fprintln(buf, "//\n//", table.Comment)
		}
		fmt.Fprintf(buf, "type %s struct {\n", tableName)
		for idx, column := range table.Columns {
			columnName := internal.Camel(column.Name)
			fields = append(fields, column.Name)
			if column.Key == "PRI" {
				primary = append(primary, column.Name)
			}

			if column.Comment != "" {
				if idx > 0 {
					fmt.Fprintln(buf)
				}
				fmt.Fprintf(buf, "	// %s\n", column.Comment)
			}
			columnType, err := resolveTypeGo(column)
			if err != nil {
				return err
			}
			jsonTag := "-"
			if options.Go.FillJSON {
				jsonTag = column.Name
			}
			if options.Go.SkipJSON {
				fmt.Fprintf(buf, "	%s %s `db:\"%s\"`\n", columnName, columnType, column.Name)
			} else {
				fmt.Fprintf(buf, "	%s %s `db:\"%s\" json:\"%s\"`\n", columnName, columnType, column.Name, jsonTag)
			}
		}
		fmt.Fprintln(buf, "}")
		fmt.Fprintln(buf)
		for _, v := range helpers {
			fmt.Fprintln(buf, v)
		}
		if len(helpers) > 0 {
			fmt.Fprintln(buf)
		}
		// Table name
		fmt.Fprintf(buf, "// %sTable is the name of the table in the DB.\n", tableName)
		// Table is SQL backtick quoted so we can allow reserved words like `group`
		fmt.Fprintf(buf, "const %sTable = \"`%s`\"\n", tableName, table.Name)
		// Table fields
		fmt.Fprintf(buf, "// %sFields is a list of all columns in the DB table.\n", tableName)
		fmt.Fprintf(buf, "var %sFields = ", tableName)
		if len(fields) > 0 {
			fmt.Fprintf(buf, "[]string{\"%s\"}", strings.Join(fields, "\", \""))
		} else {
			fmt.Fprintf(buf, "[]string{}")
		}
		fmt.Fprintln(buf)
		// Table primary keys
		fmt.Fprintf(buf, "// %sPrimaryFields are the primary key fields in the DB table.\n", tableName)
		fmt.Fprintf(buf, "var %sPrimaryFields = ", tableName)
		if len(primary) > 0 {
			fmt.Fprintf(buf, "[]string{\"%s\"}", strings.Join(primary, "\", \""))
		} else {
			fmt.Fprintf(buf, "[]string{}")
		}
		fmt.Fprintln(buf)
	}

	for _, table := range tables {
		if table.Ignore() {
			continue
		}

		tableName := internal.Camel(table.Name)
		receiver := strings.ToLower(string(tableName[0]))
		fields := []string{}

		for _, column := range table.Columns {
			fields = append(fields, column.Name)
		}

		renderQueryMethods(buf, tableName, receiver, table.Name, fields)
	}

	filename := path.Join(output, "types.mig.go")
	contents := buf.Bytes()

	formatted, err := format.Source(contents)
	if err != nil {
		// fall back to unformatted source to inspect
		// the saved file for the error which occurred
		formatted = contents
		log.WithError(err).Errorf("error formatting %s", filename)
	}

	log.Info(filename)

	return ioutil.WriteFile(filename, formatted, 0644)
}

func renderQueryBuilders(buf *bytes.Buffer) {
	fmt.Fprintln(buf, "type QueryOption interface {")
	fmt.Fprintln(buf, "	WithTable(name string) QueryOption")
	fmt.Fprintln(buf, "	WithColumns(cols []string) QueryOption")
	fmt.Fprintln(buf, "	WithWhere(clause string) QueryOption")
	fmt.Fprintln(buf, "	WithOrderBy(clause string) QueryOption")
	fmt.Fprintln(buf, "	WithLimit(start, offset int) QueryOption")
	fmt.Fprintln(buf, "	WithStatement(stmt string) QueryOption")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "type QueryConfig struct {")
	fmt.Fprintln(buf, "	Table       string")
	fmt.Fprintln(buf, "	Columns     []string")
	fmt.Fprintln(buf, "	Where       string")
	fmt.Fprintln(buf, "	OrderBy     string")
	fmt.Fprintln(buf, "	LimitStart  int")
	fmt.Fprintln(buf, "	LimitOffset int")
	fmt.Fprintln(buf, "	Statement   string")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func (q *QueryConfig) WithTable(name string) QueryOption {")
	fmt.Fprintln(buf, "	q.Table = name")
	fmt.Fprintln(buf, "	return q")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func (q *QueryConfig) WithColumns(cols []string) QueryOption {")
	fmt.Fprintln(buf, "	q.Columns = cols")
	fmt.Fprintln(buf, "	return q")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func (q *QueryConfig) WithWhere(clause string) QueryOption {")
	fmt.Fprintln(buf, "	q.Where = clause")
	fmt.Fprintln(buf, "	return q")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func (q *QueryConfig) WithOrderBy(clause string) QueryOption {")
	fmt.Fprintln(buf, "	q.OrderBy = clause")
	fmt.Fprintln(buf, "	return q")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func (q *QueryConfig) WithLimit(start, offset int) QueryOption {")
	fmt.Fprintln(buf, "	q.LimitStart = start")
	fmt.Fprintln(buf, "	q.LimitOffset = offset")
	fmt.Fprintln(buf, "	return q")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func (q *QueryConfig) WithStatement(stmt string) QueryOption {")
	fmt.Fprintln(buf, "	q.Statement = stmt")
	fmt.Fprintln(buf, "	return q")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func WithTable(name string) QueryOption {")
	fmt.Fprintln(buf, "	return &QueryConfig{Table: name}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func WithColumns(cols []string) QueryOption {")
	fmt.Fprintln(buf, "	return &QueryConfig{Columns: cols}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func WithWhere(clause string) QueryOption {")
	fmt.Fprintln(buf, "	return &QueryConfig{Where: clause}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func WithOrderBy(clause string) QueryOption {")
	fmt.Fprintln(buf, "	return &QueryConfig{OrderBy: clause}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func WithLimit(start, offset int) QueryOption {")
	fmt.Fprintln(buf, "	return &QueryConfig{LimitStart: start, LimitOffset: offset}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func WithStatement(stmt string) QueryOption {")
	fmt.Fprintln(buf, "	return &QueryConfig{Statement: stmt}")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)

	fmt.Fprintln(buf, "func (q *QueryConfig) Apply(opts ...QueryOption) *QueryConfig {")
	fmt.Fprintln(buf, "	cfg := *q")
	fmt.Fprintln(buf, "	for _, opt := range opts {")
	fmt.Fprintln(buf, "		o := opt.(*QueryConfig)")
	fmt.Fprintln(buf, "		if o.Table != \"\" {")
	fmt.Fprintln(buf, "			cfg.Table = o.Table")
	fmt.Fprintln(buf, "		}")
	fmt.Fprintln(buf, "		if len(o.Columns) > 0 {")
	fmt.Fprintln(buf, "			cfg.Columns = o.Columns")
	fmt.Fprintln(buf, "		}")
	fmt.Fprintln(buf, "		if o.Where != \"\" {")
	fmt.Fprintln(buf, "			cfg.Where = o.Where")
	fmt.Fprintln(buf, "		}")
	fmt.Fprintln(buf, "		if o.OrderBy != \"\" {")
	fmt.Fprintln(buf, "			cfg.OrderBy = o.OrderBy")
	fmt.Fprintln(buf, "		}")
	fmt.Fprintln(buf, "		if o.LimitOffset > 0 {")
	fmt.Fprintln(buf, "			cfg.LimitStart = o.LimitStart")
	fmt.Fprintln(buf, "			cfg.LimitOffset = o.LimitOffset")
	fmt.Fprintln(buf, "		}")
	fmt.Fprintln(buf, "		if o.Statement != \"\" {")
	fmt.Fprintln(buf, "			cfg.Statement = o.Statement")
	fmt.Fprintln(buf, "		}")
	fmt.Fprintln(buf, "	}")
	fmt.Fprintln(buf, "	return &cfg")
	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)
}

func renderQueryMethods(buf *bytes.Buffer, typeName, receiver, tableName string, fields []string) {
	fmt.Fprintf(buf, "func (%s *%s) Insert(opts ...QueryOption) string {\n", receiver, typeName)
	fmt.Fprintf(buf, "	cfg := (&QueryConfig{Table: %sTable, Statement: \"INSERT INTO\"}).Apply(opts...)\n", typeName)
	fmt.Fprintf(buf, "	cols := %sFields\n", typeName)
	fmt.Fprintf(buf, "	if len(cfg.Columns) > 0 { cols = cfg.Columns }\n")
	fmt.Fprintf(buf, "	return fmt.Sprintf(\"%%s %%s (%%s) VALUES (:%%s)\", cfg.Statement, cfg.Table, strings.Join(cols, \", \"), strings.Join(cols, \", :\"))\n")
	fmt.Fprintf(buf, "}\n")
	fmt.Fprintln(buf)

	fmt.Fprintf(buf, "func (%s *%s) Select(opts ...QueryOption) string {\n", receiver, typeName)
	fmt.Fprintf(buf, "	cfg := (&QueryConfig{Table: %sTable}).Apply(opts...)\n", typeName)
	fmt.Fprintf(buf, "	cols := \"*\"\n")
	fmt.Fprintf(buf, "	if len(cfg.Columns) > 0 { cols = strings.Join(cfg.Columns, \", \") }\n")
	fmt.Fprintf(buf, "	query := fmt.Sprintf(\"SELECT %%s FROM %%s\", cols, cfg.Table)\n")
	fmt.Fprintf(buf, "	if cfg.Where != \"\" { query += \" WHERE \" + cfg.Where }\n")
	fmt.Fprintf(buf, "	if cfg.OrderBy != \"\" { query += \" ORDER BY \" + cfg.OrderBy }\n")
	fmt.Fprintf(buf, "	if cfg.LimitOffset > 0 { query += fmt.Sprintf(\" LIMIT %%d, %%d\", cfg.LimitStart, cfg.LimitOffset) }\n")
	fmt.Fprintf(buf, "	return query\n")
	fmt.Fprintf(buf, "}\n")
	fmt.Fprintln(buf)

	fmt.Fprintf(buf, "func (%s *%s) Update(opts ...QueryOption) string {\n", receiver, typeName)
	fmt.Fprintf(buf, "	cfg := (&QueryConfig{Table: %sTable}).Apply(opts...)\n", typeName)
	fmt.Fprintf(buf, "	cols := %sFields\n", typeName)
	fmt.Fprintf(buf, "	if len(cfg.Columns) > 0 { cols = cfg.Columns }\n")
	fmt.Fprintf(buf, "	setClause := \"\"\n")
	fmt.Fprintf(buf, "	for i, col := range cols {\n")
	fmt.Fprintf(buf, "		if i > 0 { setClause += \", \" }\n")
	fmt.Fprintf(buf, "		setClause += col + \"=:\" + col\n")
	fmt.Fprintf(buf, "	}\n")
	fmt.Fprintf(buf, "	query := fmt.Sprintf(\"UPDATE %%s SET %%s\", cfg.Table, setClause)\n")
	fmt.Fprintf(buf, "	if cfg.Where != \"\" { query += \" WHERE \" + cfg.Where }\n")
	fmt.Fprintf(buf, "	return query\n")
	fmt.Fprintf(buf, "}\n")
	fmt.Fprintln(buf)

	fmt.Fprintf(buf, "func (%s *%s) Delete(opts ...QueryOption) string {\n", receiver, typeName)
	fmt.Fprintf(buf, "	cfg := (&QueryConfig{Table: %sTable}).Apply(opts...)\n", typeName)
	fmt.Fprintf(buf, "	query := fmt.Sprintf(\"DELETE FROM %%s\", cfg.Table)\n")
	fmt.Fprintf(buf, "	if cfg.Where != \"\" { query += \" WHERE \" + cfg.Where }\n")
	fmt.Fprintf(buf, "	return query\n")
	fmt.Fprintf(buf, "}\n")
	fmt.Fprintln(buf)
}
