package model

// Code generated by go-bridget/mig. DO NOT EDIT.

import (
	"fmt"
	"strings"
	"time"
)

// QueryOption is implemented by each data model type.
type QueryOption interface {
	WithTable(name string) QueryOption
	WithColumns(cols []string) QueryOption
	WithWhere(clause string) QueryOption
	WithOrderBy(clause string) QueryOption
	WithLimit(start, offset int) QueryOption
	WithStatement(stmt string) QueryOption
}

// QueryConfig is a function-chaining SQL statement type.
type QueryConfig struct {
	Table       string
	Columns     []string
	Where       string
	OrderBy     string
	LimitStart  int
	LimitOffset int
	Statement   string
}

// WithTable will set the table name for the query.
func (q *QueryConfig) WithTable(name string) QueryOption {
	q.Table = name
	return q
}

// WithColumns will set the columns to use for the query.
func (q *QueryConfig) WithColumns(cols []string) QueryOption {
	q.Columns = cols
	return q
}

// WithWhere will set the where condition for the query.
func (q *QueryConfig) WithWhere(clause string) QueryOption {
	q.Where = clause
	return q
}

// WithOrderBy will set the order by clause for the query.
func (q *QueryConfig) WithOrderBy(clause string) QueryOption {
	q.OrderBy = clause
	return q
}

// WithLimit will set the limit clause parameters for the query.
func (q *QueryConfig) WithLimit(start, offset int) QueryOption {
	q.LimitStart = start
	q.LimitOffset = offset
	return q
}

// WithStatement will change the statement for the query.
func (q *QueryConfig) WithStatement(stmt string) QueryOption {
	q.Statement = stmt
	return q
}

// WithTable will set the table name for the query.
func WithTable(name string) QueryOption {
	return &QueryConfig{Table: name}
}

// WithColumns will set the columns to use for the query.
func WithColumns(cols []string) QueryOption {
	return &QueryConfig{Columns: cols}
}

// WithWhere will set the where condition for the query.
func WithWhere(clause string) QueryOption {
	return &QueryConfig{Where: clause}
}

// WithOrderBy will set the order by clause for the query.
func WithOrderBy(clause string) QueryOption {
	return &QueryConfig{OrderBy: clause}
}

// WithLimit will set the limit clause parameters for the query.
func WithLimit(start, offset int) QueryOption {
	return &QueryConfig{LimitStart: start, LimitOffset: offset}
}

// WithStatement will change the statement for the query.
func WithStatement(stmt string) QueryOption {
	return &QueryConfig{Statement: stmt}
}

func (q *QueryConfig) Apply(opts ...QueryOption) *QueryConfig {
	cfg := *q
	for _, opt := range opts {
		o := opt.(*QueryConfig)
		if o.Table != "" {
			cfg.Table = o.Table
		}
		if len(o.Columns) > 0 {
			cfg.Columns = o.Columns
		}
		if o.Where != "" {
			cfg.Where = o.Where
		}
		if o.OrderBy != "" {
			cfg.OrderBy = o.OrderBy
		}
		if o.LimitOffset > 0 {
			cfg.LimitStart = o.LimitStart
			cfg.LimitOffset = o.LimitOffset
		}
		if o.Statement != "" {
			cfg.Statement = o.Statement
		}
	}
	return &cfg
}

// Event generated for db table `event`.
//
// Event.
type Event struct {
	// ID
	ID int64 `db:"id" json:"-"`

	// Title
	Title string `db:"title" json:"-"`

	// Description
	Description string `db:"description" json:"-"`

	// Tags
	Tags string `db:"tags" json:"-"`

	// Status
	Status string `db:"status" json:"-"`

	// Payload
	Payload string `db:"payload" json:"-"`

	// Retry Count
	RetryCount int64 `db:"retry_count" json:"-"`

	// Max Retries
	MaxRetries int64 `db:"max_retries" json:"-"`

	// Next Retry At
	NextRetryAt *time.Time `db:"next_retry_at" json:"-"`

	// Created At
	CreatedAt *time.Time `db:"created_at" json:"-"`

	// Updated At
	UpdatedAt *time.Time `db:"updated_at" json:"-"`
}

// GetID will return the value of ID.
func (e *Event) GetID() int64 { return e.ID }

// GetTitle will return the value of Title.
func (e *Event) GetTitle() string { return e.Title }

// GetDescription will return the value of Description.
func (e *Event) GetDescription() string { return e.Description }

// GetTags will return the value of Tags.
func (e *Event) GetTags() string { return e.Tags }

// GetStatus will return the value of Status.
func (e *Event) GetStatus() string { return e.Status }

// GetPayload will return the value of Payload.
func (e *Event) GetPayload() string { return e.Payload }

// GetRetryCount will return the value of RetryCount.
func (e *Event) GetRetryCount() int64 { return e.RetryCount }

// GetMaxRetries will return the value of MaxRetries.
func (e *Event) GetMaxRetries() int64 { return e.MaxRetries }

// GetNextRetryAt will return the value of NextRetryAt.
func (e *Event) GetNextRetryAt() *time.Time { return e.NextRetryAt }

// SetNextRetryAt sets NextRetryAt to the provided value.
func (e *Event) SetNextRetryAt(stamp time.Time) { e.NextRetryAt = &stamp }

// GetCreatedAt will return the value of CreatedAt.
func (e *Event) GetCreatedAt() *time.Time { return e.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (e *Event) SetCreatedAt(stamp time.Time) { e.CreatedAt = &stamp }

// GetUpdatedAt will return the value of UpdatedAt.
func (e *Event) GetUpdatedAt() *time.Time { return e.UpdatedAt }

// SetUpdatedAt sets UpdatedAt to the provided value.
func (e *Event) SetUpdatedAt(stamp time.Time) { e.UpdatedAt = &stamp }

// EventTable is the name of the table in the DB.
const EventTable = "`event`"

// EventFields is a list of all columns in the DB table.
var EventFields = []string{"id", "title", "description", "tags", "status", "payload", "retry_count", "max_retries", "next_retry_at", "created_at", "updated_at"}

// EventPrimaryFields are the primary key fields in the DB table.
var EventPrimaryFields = []string{"id"}

// EventLog generated for db table `event_log`.
//
// Event Log.
type EventLog struct {
	// ID
	ID int64 `db:"id" json:"-"`

	// Event ID
	EventID int64 `db:"event_id" json:"-"`

	// Worker ID
	WorkerID string `db:"worker_id" json:"-"`

	// Action
	Action string `db:"action" json:"-"`

	// Status Code
	StatusCode int64 `db:"status_code" json:"-"`

	// Error Message
	ErrorMessage string `db:"error_message" json:"-"`

	// Execution Time Ms
	ExecutionTimeMs int64 `db:"execution_time_ms" json:"-"`

	// Created At
	CreatedAt *time.Time `db:"created_at" json:"-"`
}

// GetID will return the value of ID.
func (e *EventLog) GetID() int64 { return e.ID }

// GetEventID will return the value of EventID.
func (e *EventLog) GetEventID() int64 { return e.EventID }

// GetWorkerID will return the value of WorkerID.
func (e *EventLog) GetWorkerID() string { return e.WorkerID }

// GetAction will return the value of Action.
func (e *EventLog) GetAction() string { return e.Action }

// GetStatusCode will return the value of StatusCode.
func (e *EventLog) GetStatusCode() int64 { return e.StatusCode }

// GetErrorMessage will return the value of ErrorMessage.
func (e *EventLog) GetErrorMessage() string { return e.ErrorMessage }

// GetExecutionTimeMs will return the value of ExecutionTimeMs.
func (e *EventLog) GetExecutionTimeMs() int64 { return e.ExecutionTimeMs }

// GetCreatedAt will return the value of CreatedAt.
func (e *EventLog) GetCreatedAt() *time.Time { return e.CreatedAt }

// SetCreatedAt sets CreatedAt to the provided value.
func (e *EventLog) SetCreatedAt(stamp time.Time) { e.CreatedAt = &stamp }

// EventLogTable is the name of the table in the DB.
const EventLogTable = "`event_log`"

// EventLogFields is a list of all columns in the DB table.
var EventLogFields = []string{"id", "event_id", "worker_id", "action", "status_code", "error_message", "execution_time_ms", "created_at"}

// EventLogPrimaryFields are the primary key fields in the DB table.
var EventLogPrimaryFields = []string{"id"}

// Migrations generated for db table `migrations`.
//
// Migrations.
type Migrations struct {
	// Project
	Project string `db:"project" json:"-"`

	// Filename
	Filename string `db:"filename" json:"-"`

	// Statement Index
	StatementIndex int64 `db:"statement_index" json:"-"`

	// Status
	Status string `db:"status" json:"-"`
}

// GetProject will return the value of Project.
func (m *Migrations) GetProject() string { return m.Project }

// GetFilename will return the value of Filename.
func (m *Migrations) GetFilename() string { return m.Filename }

// GetStatementIndex will return the value of StatementIndex.
func (m *Migrations) GetStatementIndex() int64 { return m.StatementIndex }

// GetStatus will return the value of Status.
func (m *Migrations) GetStatus() string { return m.Status }

// MigrationsTable is the name of the table in the DB.
const MigrationsTable = "`migrations`"

// MigrationsFields is a list of all columns in the DB table.
var MigrationsFields = []string{"project", "filename", "statement_index", "status"}

// MigrationsPrimaryFields are the primary key fields in the DB table.
var MigrationsPrimaryFields = []string{"project", "filename"}

func (e *Event) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := EventFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

func (e *Event) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

func (e *Event) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventTable}).Apply(opts...)
	cols := EventFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *Event) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *EventLog) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventLogTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := EventLogFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

func (e *EventLog) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventLogTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

func (e *EventLog) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventLogTable}).Apply(opts...)
	cols := EventLogFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (e *EventLog) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: EventLogTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (m *Migrations) Insert(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable, Statement: "INSERT INTO"}).Apply(opts...)
	cols := MigrationsFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	return fmt.Sprintf("%s %s (%s) VALUES (:%s)", cfg.Statement, cfg.Table, strings.Join(cols, ", "), strings.Join(cols, ", :"))
}

func (m *Migrations) Select(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	cols := "*"
	if len(cfg.Columns) > 0 {
		cols = strings.Join(cfg.Columns, ", ")
	}
	query := fmt.Sprintf("SELECT %s FROM %s", cols, cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	if cfg.OrderBy != "" {
		query += " ORDER BY " + cfg.OrderBy
	}
	if cfg.LimitOffset > 0 {
		query += fmt.Sprintf(" LIMIT %d, %d", cfg.LimitStart, cfg.LimitOffset)
	}
	return query
}

func (m *Migrations) Update(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	cols := MigrationsFields
	if len(cfg.Columns) > 0 {
		cols = cfg.Columns
	}
	setClause := ""
	for i, col := range cols {
		if i > 0 {
			setClause += ", "
		}
		setClause += col + "=:" + col
	}
	query := fmt.Sprintf("UPDATE %s SET %s", cfg.Table, setClause)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}

func (m *Migrations) Delete(opts ...QueryOption) string {
	cfg := (&QueryConfig{Table: MigrationsTable}).Apply(opts...)
	query := fmt.Sprintf("DELETE FROM %s", cfg.Table)
	if cfg.Where != "" {
		query += " WHERE " + cfg.Where
	}
	return query
}
